# Mock Network Requests in React Native Testing Library with Mirage

Use your Mirage server to test your React Native application under different server scenarios using [@testing-library/react-native](https://github.com/testing-library/native-testing-library) and [Jest Native](https://github.com/testing-library/jest-native).

> This is a quickstart guide for people familiar with React Native Testing Library and Jest Native. However, it should also work with both [react-test-renderer](https://reactjs.org/docs/test-renderer.html) and [react-native-testing-library](https://github.com/callstack/react-native-testing-library).

## Step 1: Install Mirage

First, make sure you have Mirage installed:

```bash
# Using npm
npm install --save-dev miragejs

# Using Yarn
yarn add --dev miragejs
```

## Step 2: Setup your testing environment

We'll need to update our Jest environment to work with Mirage.

First, install the polyfill for XMLHttpRequest:

```bash
# Using npm
npm install --save-dev xmlhttprequest

# Using Yarn
yarn add --dev xmlhttprequest
```

Then create a new `jest.setup.js` file in the root of your project. We'll use this file to patch the `global` variable and add support for XMLHttpRequest, self, and window.

```js
// jest.setup.js
global.self = global
global.window = {}
global.XMLHttpRequest = require("xmlhttprequest").XMLHttpRequest
```

Finally, have Jest to load the environment that we just created using `jest.config.js`.

```js
// jest.config.js
const jestPreset = require("@testing-library/react-native/jest-preset")

module.exports = {
  preset: "@testing-library/react-native",
  setupFiles: [...jestPreset.setupFiles],
  setupFilesAfterEnv: ["./jest.setup.js"],
}
```

Here we're telling Jest to execute our `jest.setup.js` after it sets up the test environment.

## Step 3: Define your server

Create a new `server.js` file and define your mock server.

```js
// server.js
import { Server, Model } from "miragejs"

export function makeServer({ environment = "development" } = {}) {
  let server = new Server({
    environment,

    models: {
      user: Model,
    },

    seeds(server) {
      server.create("user", { name: "Bob" })
      server.create("user", { name: "Alice" })
    },

    routes() {
      this.namespace = "api"

      this.get("/users", schema => {
        return schema.users.all()
      })
    },
  })

  return server
}
```

## Step 4: Create a test file that uses Mirage

Here's the component we'll be testing.

```jsx
// App.js
const App = () => {
  let [users, setUsers] = useState([])
  let [serverError, setServerError] = useState()

  useEffect(() => {
    let fetchUsers = async () => {
      try {
        let res = await fetch("/api/users")
        let data = await res.json()
        data.error ? setServerError(data.error) : setUsers(data.users)
      } catch (error) {
        setServerError(error.message)
      }
    }

    fetchUsers()
  }, [])

  return (
    <SafeAreaView style={{ flex: 1 }}>
      {serverError ? (
        <Text testID="server-error">{serverError}</Text>
      ) : users.length === 0 ? (
        <Text testID="no-users">No users!</Text>
      ) : (
        users.map(user => (
          <View key={user.id} testID="users">
            <Text testID={`user-${user.id}`}>{user.name}</Text>
          </View>
        ))
      )}
    </SafeAreaView>
  )
}

export default App
```

Create a new `App.test.js` file, import your `makeServer` function, and start and shutdown Mirage using `beforeEach` and `afterEach`, making sure to pass the `test` environment to Mirage:

```js
// App.test.js
import React from "react"
import { render, waitForElement } from "@testing-library/react-native"
import App from "../App"
import { makeServer } from "../server"

let server

beforeEach(() => {
  server = makeServer({ environment: "test" })
})

afterEach(() => {
  server.shutdown()
})
```

## Step 5: Write tests using your Mirage server

Use your tests to seed Mirage with different data scenarios, then assert against the state of your UI.

> In the `test` environment, Mirage doesn't load its database `seeds`, so that the server starts out empty for each test run.

```js
// App.test.js
it("shows the users from our server", async () => {
  server.create("user", { name: "Luke" })
  server.create("user", { name: "Leia" })

  const { getByTestId } = render(<App />)
  await waitForElement(() => getByTestId("user-1"))
  await waitForElement(() => getByTestId("user-2"))

  expect(getByTestId("user-1")).toHaveTextContent("Luke")
  expect(getByTestId("user-2")).toHaveTextContent("Leia")
})

it("shows a message if there are no users", async () => {
  // Don't create any users

  const { getByTestId } = render(<App />)
  await waitForElement(() => getByTestId("no-users"))

  expect(getByTestId("no-users")).toHaveTextContent("No users!")
})
```

## Step 6: Alter your Mirage server to test different server states

In addition to different data scenarios, you can use your tests to reconfigure your Mirage server to test new situations.

For example, you can test an error state like this:

```js
// App.test.js
import { Response } from "miragejs"

it("handles error responses from the server", async () => {
  // Override Mirage's route handler for /users, just for this test
  server.get("/users", () => {
    return new Response(
      500,
      {},
      {
        error: "The database is on vacation.",
      }
    )
  })

  const { getByTestId } = render(<App />)

  await waitForElement(() => getByTestId("server-error"))

  expect(getByTestId("server-error")).toHaveTextContent(
    "The database is on vacation."
  )
})
```

Because of the way we setup Mirage using `beforeEach` and `afterEach`, each test will get a fresh Mirage server based on your main server definition. Any overrides you make within a test will be isolated to that test.
