# React

Setting up Mirage with a React app is easy, whether you're using Create React App or some other environment. You only need a single file.

Make sure you have Mirage installed in your project:

```bash
# Using npm
npm install --save-dev miragejs

# Using Yarn
yarn add --dev miragejs
```

## Defining the server

Create a new file, `src/server.js`, that will hold the code for our mock server. To get started quickly, let's use the following server definition. Paste this code into the new `server.js` file.

```js
// src/server.js

import { Server } from "miragejs"

export function makeServer({ environment = "development" } = {}) {
  let server = new Server({
    environment,

    routes() {
      this.namespace = "api"

      this.get("/users", () => {
        return {
          users: [
            {
              id: 1,
              name: "Bob",
            },
            {
              id: 2,
              name: "Alice",
            },
          ],
        }
      })
    },
  })

  return server
}
```

This server defines a single endpoint, `/api/users`, that responds with a JSON payload containing two users, Bob and Alice. That's it!

Here, we're exporting a `makeServer` function that will let us customize our Mirage server in the development and testing environments. This is one good approach, but feel free to customize this file however you like. The only thing that's Mirage-specific is the call to `new Server()`.

## Using our server in Development

Now that we have our server defined, let's get it running in development.

We'll open our React app's `src/index.js` file, import the `makeServer` function, and invoke it in development.

```diff
import React from "react";
import ReactDOM from "react-dom";
import App from "./App";
+ import { makeServer } from "./server";

+ if (process.env.NODE_ENV === 'development') {
+   makeServer();
+ }

ReactDOM.render(<App />, document.getElementById("root"));
```

Mirage is now running when our app boots up in development! As the application attempts to fetch data from the network, Mirage will step in to handle the request. The following App component fetches the two users that were defined in our `routes()` config:

```jsx
// src/App.js

import { useState, useEffect } from "react"

export default function App() {
  let [users, setUsers] = useState([])

  useEffect(() => {
    let fetchUsers = async function() {
      let res = await fetch("/api/users")
      let json = await res.json()
      setUsers(json.users)
    }

    fetchUsers()
  }, [])

  return (
    <ul data-testid="users">
      {users.map(user => (
        <li key={user.id} data-testid={`user-${user.id}`}>
          {user.name}
        </li>
      ))}
    </ul>
  )
}
```

That's it! Our component will now render a list with both of our users, Bob and Alice.

## Using our server in Testing

Next, let's use our Mirage server to test our App component.

> For this next section we're going to use Jest with React Testing Library. If you're unfamiliar with these libraries take a look at their [guides](https://testing-library.com/docs/react-testing-library/intro).

Create a new test for the App component in `src/__tests__/App.test.js`. To get started, copy in the following Jest code.

```js
// src/__tests__/App.test.js

import React from "react";
import {
  render,
  waitForElement,
} from "@testing-library/react";
import App from "../App";
import { makeServer } from "../server";

let server;

beforeEach(() => {
  server = makeServer({ environment: "test" });
});

afterEach(() => {
  server.shutdown();
});

it("loads the users from our server", () => {
  const { getByTestId } = render(<App />);

  await waitForElement(() => getByTestId("user-1"));
  await waitForElement(() => getByTestId("user-2"));

  expect(getByTestId("user-1")).toHaveTextContent("Bob");
  expect(getByTestId("user-2")).toHaveTextContent("Alice");
});
```

Let's talk about what's going on in this test file.

In the `beforeEach` hook we're creating a new server using the same `makeServer` function we defined earlier. We're initializing our server with a `test` environment, which optimizes Mirage to run inside of tests.

In the `afterEach` hook we're calling `server.shutdown()`, which will destroy our Mirage server. This ensures that every test we write has its own isolated server and no server state is shared between any two tests.

Finally, our test renders our App component and asserts that the names Bob and Alice show up on the page.

While this test covers the data loading functionality of our component there's something missing. Testing components like this will maximize our confidence in them being able to take on various states. However, we also must be able to answer additional questions like: "What happens when the server has no users?", or "What does our component render if the backend 500's?"

This is where Mirage shines, it has the ability to quickly create and test these scenarios, which makes answering those questions a breeze.

Let's go back to our `src/server.js` file and make a small change to its definition.

```diff
// src/server.js

- import { Server } from "miragejs"
+ import { Server, Model } from "miragejs"

export function makeServer({ environment = "development" } = {}) {
  let server = new Server({
    environment,

+   models: {
+     user: Model
+   },

    routes() {
      this.namespace = "api"

-     this.get("/users", () => {
-       return {
-         users: [
-           {
-             id: 1,
-             name: "Bob",
-           },
-           {
-             id: 2,
-             name: "Alice",
-          },
-        ],
-      }
-    })

+    this.get('/users', (schema) => {
+      return schema.users.all();
+    });
   },
  })

  return server
}
```

With this change we're telling Mirage that `users` are a first class [model](/docs/data-layer/models) in our server. We're also changing the `/api/users` endpoint to respond with all users in the server, instead of a static list containing only Bob and Alice.

Now we have the ability to test our server in various states. Let's use Mirage to create a test with a single user.

```js
// src/__tests__/App.test.js

it("loads the a single user from our server", () => {
  server.create('user', { name: 'John' });

  const { getByTestId } = render(<App />);

  await waitForElement(() => getByTestId("user-1"));

  expect(getByTestId("user-1")).toHaveTextContent("John");
});
```

By using `server.create()` we are taking advantage of Mirage's [factories](http://localhost:8000/docs/data-layer/factories) to define data that is specifically tailored to each test.

We can also use Mirage to test error responses from our server.

```js
// src/__tests__/App.test.js

import { Response } from "miragejs"

it("handles error responses from the server", () => {
  server.get("/users", () => {
    return new Response(
      500,
      {},
      { errors: ["The database is on vacation."]}
    )
  });

  const { getByTestId } = render(<App />);

  await waitForElement(() => getByTestId("server-error"));

  expect(getByTestId("server-error"))
    .toHaveTextContent("The database is on vacation.");
});
```

That's it for getting Mirage into a React app, but there's so much more that Mirage can do! Take a look at the [guides](/docs/getting-started/introduction) to explore more of the API.
